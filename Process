RAM has address space 0-24
SSD has address space 0-99
HDD has address spce 0-999


---------
Determining if a memory heirarchy is full
---------
At the very beginning, all pages in the table are unallocated (allocated = 0)

We go through the page table and count the number of times we see an item at the desired level with allocated == 1. If the number is less than the capacity of the memory level, then there is space. 

---------
Functions
---------

allocateNewInt will:
	-put an item in the next available spot in RAM
	-If ram is full, evict a page and try to allocate again.
	-return the vAddr of the newly added page (0-999)


accessIntPtr will:
	-given an address, "x", between 0 and 999 (say, 234)
	-Search the page table for an item with address x

	-if the level of this entry is RAM, return a pointer to RAM[address]
	-if the level is not RAM, check for a free spot in RAM
		-if there is a free spot, update the page so that the address points to RAM's index  



---------
Page Table
---------

For each item in any level of the system's storage, we keep a page table entry
This table stores the following about each entry:

	Location - (vAddr) the location of the item in storage (ranges from 0-999)
	Locked - whether or not the memory is currently locked or not
	Dirty - Do we need to write the item to the upper levels, or can we just get rid of it?
	Referenced - whether or not the item has been referenced recently
	Allocated - whether or not the space is in use or not
	Level - what storage level the item is in (RAM, SSD, HDD...)

-------------------------
Dealing with page faults
-------------------------

	1. Determine the location of the data in secondary storage.
	2. Obtain an empty page frame in RAM to use as a container for the data.
	3. Load the requested data into the available page frame.
	4. Update the page table to refer to the new page frame.
	5. Return control to the program, transparently retrying the instruction that caused the page fault.


