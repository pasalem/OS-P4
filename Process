RAM has address space 0-24
SSD has address space 0-99
HDD has address spce 0-999


---------
Determining if a memory heirarchy is full
---------

	Keep a counter for the number of items in each level and increment/decrement as needed. If we do this, though, what happens if things are removed in memory out of place? Then we have lost the last available space. 

	We need a method to determine where the first open spot in memory is. If we just use a counter, then memory assumes we are always adding to spot 24. 



---------
Functions
---------

allocateNewInt will:
	-put an item in the next available spot in RAM
	-if necessary, evict an item from RAM using a page replacement algorithm
		+put the old values in RAM higher up in the memory heirarchy
	-returns the value of the newly taken spot in RAM


accessIntPtr will:
	-Make a pass through the page table. Keep a best match page struct to fill.
	-If we find an item in the page table that has the given address, save it to the page struct above.
	-Keep looking. if we find an allocated page at a lower level, update the best match page. 
	-If we end up finding a match in RAM, return it.
	-if the page is not in RAM, run the eviction algorithm, put it in RAM

---------
Page Table
---------

For each item in any level of the system's storage, we keep a page table entry
This table stores the following about each entry:

	Location - (vAddr) the location of the item in storage (ranges from 0-999)
	Locked - whether or not the memory is currently locked or not
	Dirty - Do we need to write the item to the upper levels, or can we just get rid of it?
	Referenced - whether or not the item has been referenced recently
	Allocated - whether or not the space is in use or not
	Level - what storage level the item is in (RAM, SSD, HDD...)

-------------------------
Dealing with page faults
-------------------------

	1. Determine the location of the data in secondary storage.
	2. Obtain an empty page frame in RAM to use as a container for the data.
	3. Load the requested data into the available page frame.
	4. Update the page table to refer to the new page frame.
	5. Return control to the program, transparently retrying the instruction that caused the page fault.


